'''
첫번째 풀이 - DP를 적용시키기 위해 미리 리스트의 크기를 n만큼 만든 후
n인 길이의 타일링 경우의 수를 구한 후 1,000,000,007을 나눈 나머지 수를
구하였다. 정확성은 모두 통과하였으나 효율성에서 시간 초과가 발생하였다.
'''
# def solution(n):
#     answer = 0
#     dp= [0] * (n+1)

#     dp[1] = 1
#     dp[2] = 2

#     for i in range(3,n+1):
#         dp[i] = dp[i-1]+dp[i-2]

#     answer = dp[n] % 1000000007
#     return answer
'''
두번째 풀이 - 위의 풀이의 코드가 간단하고 n의 최대값이 60,000인것을 생각하여
어느 곳이 문제인지를 파악하는데 많은 고민을 하였다. 그러다가 해당 문제는 
다른 dp문제와는 달리 오직 큰 문제를 작게나눈 문제들이 한 번씩 밖에 쓰이지 
않는다는 것을 깨달았다. 그래서 굳이 리스트를 선언하지 않고 변수를 수정하는
방향으로 문제를 풀었고 문제가 해결되었다.
'''
# def solution(n):
#     answer = 0
#
#     dp1 = 1
#     dp2 = 2
#
#     for _ in range(3, n + 1):
#         dp2, dp1 = dp2 + dp1, dp2
#
#     answer = dp2 % 1000000007
#     return answer

'''
마지막 풀이 - 문제를 해결하였지만 최대 60,000개의 리스트 크기가 이렇게나 시간 복잡도를 가지는 것이 의아했다. 그래서 놓친 부분이 있는지 찾아
보게 되었다. 혹시 너무 큰 수를 연산하는 것이 시간이 느려지는 원인이 아닐까 생각하여 다 구한 후 나머지를 구하는 방향에서 처음부터 나머지를
구하는 생각을 해보았다. 그 결과 문제가 해결되었으며 위의 방법보다 더 빠른 시간 안에 해결되었다. 이것으로 보아 이렇게 큰 수를 컴퓨터가 계산할
때는 성능에 지장이 있다는 것을 알게 되었다.
또한 왜 1,000,000,007라는 수가 나누는 수의 기준이 되는지 궁금하였다. 구글링읕 통해 알아 본 결과, 해당 수는 c언어에서 long long 자료형에서
연산을 할 때 성능에 무리가 가지 않는 최대의 수이기 때문이었다.  
'''
def solution(n):
    answer = 0
    dp= [0] * (n+1)

    dp[1] = 1
    dp[2] = 2

    for i in range(3,n+1):
        dp[i] = (dp[i-1]+dp[i-2]) % 1000000007

    answer = dp[-1]
    return answer